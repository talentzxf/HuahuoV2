using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using UnityEditor.Build.Reporting;
using UnityEditor.Modules;
using UnityEditor.Utils;
using UnityEditor.WebGL.Emscripten;
using UnityEditor.WebGL.Il2Cpp;
using UnityEditorInternal;

namespace UnityEditor.WebGL
{
    internal class WebGLStrippingInfo : Build.Reporting.StrippingInfoWithSizeAnalysis
    {
        public string builtCodePath;
        public bool developmentBuild;

        static char[] objectTrimChar = new char[] {':'};
        static string[] objectTrimPrefixes = new string[]
        {
            "Temp/",
            "lib/modules/WebGLSupport_",
            "lib/modules_development/WebGLSupport_"
        };

        static string ParseObjectName(string obj)
        {
            string result = obj;

            result = result.Trim(objectTrimChar);
            foreach (var prefix in objectTrimPrefixes)
            {
                var index = result.Replace('\\', '/').IndexOf(prefix);
                if (index != -1)
                    result = result.Substring(index + prefix.Length);
            }
            return result;
        }

        static private string[] GetDirectorySymbolArtifacts(string directory)
        {
            var il2cppObjects = Directory.GetFiles(directory, "*", SearchOption.AllDirectories);

            var processStartInfo = new ProcessStartInfo(EmscriptenPaths.nmExecutable)
            {
                Arguments = "-n " + il2cppObjects.Aggregate("", (current, additionalFile) => current + " \"" + additionalFile + "\""),
                UseShellExecute = false,
                CreateNoWindow = true
            };
            var p = new Program(processStartInfo);
            p.Start();
            p.WaitForExit();
            return p.GetStandardOutput();
        }

        static private string[] GetDirectorySymbolArtifactsFromGeneratedCode(string directory)
        {
            // When we have many object files to pass to llvm-nm, the command line can get to large quickly.
            // This happens with the object files from code generated by IL2CPP and the object files from libil2cpp. We
            // try to help here by pass llvm-nm the object files not using the full path, but instead using only the first
            // directory name and the object file name. We then set the working directory for the process to be one
            // directory above the directory where all of the object files are located.
            //
            // Note that we cannot just pass the object files directly, as the code which calls this function requires the llvm-nm
            // output to include at least one directory for each object file so that it can parse the output correctly.
            var firstSubdirectory = LeafDirectoryFor(directory);
            var il2cppObjects = Directory.GetFiles(directory).Select(path => Path.Combine(firstSubdirectory, Path.GetFileName(path)));

            var processStartInfo = new ProcessStartInfo(EmscriptenPaths.nmExecutable)
            {
                Arguments = "-n " + il2cppObjects.Aggregate("", (current, additionalFile) => current + " \"" + additionalFile + "\""),
                UseShellExecute = false,
                CreateNoWindow = true,
                WorkingDirectory = Path.GetDirectoryName(UseForwardSlashesAndTrimTrailingSlashFromDirectoryName(directory)),
            };
            var p = new Program(processStartInfo);
            p.Start();
            p.WaitForExit();
            return p.GetStandardOutput();
        }

        static private IEnumerable<string> GetSourceCodeSymbolArtifacts()
        {
            var playerPackage = UnityEditor.BuildPipeline.GetPlaybackEngineDirectory(BuildTarget.WebGL, BuildOptions.None);
            var unityTree = FileUtil.DeleteLastPathNameComponent(FileUtil.DeleteLastPathNameComponent(playerPackage));
            var artifacts = Paths.Combine(unityTree, "artifacts");
            IEnumerable<string> symbolArtifactsList = new string[0];
            var webGLSourceDirectories = Directory.GetDirectories(artifacts, "webgl_release*1");
            foreach (var directory in webGLSourceDirectories)
                symbolArtifactsList = symbolArtifactsList.Concat(GetDirectorySymbolArtifacts(Paths.Combine(artifacts, directory)));
            return symbolArtifactsList;
        }

        private static string LeafDirectoryFor(string directory)
        {
            directory = UseForwardSlashesAndTrimTrailingSlashFromDirectoryName(directory);
            var firstSubdirectory = Path.GetFileName(directory);
            return firstSubdirectory;
        }

        private static string UseForwardSlashesAndTrimTrailingSlashFromDirectoryName(string directory)
        {
            directory = directory.Replace('\\', '/');
            directory = directory.TrimEnd('/');
            return directory;
        }

        static private Dictionary<string, string> GetSymbolArtifactsFromNMOutput(IEnumerable<string> lines)
        {
            var result = new Dictionary<string, string>();
            string curObject = null;
            var trimChars = new char[] {'_', '-', ' '};
            foreach (var l in lines)
            {
                if (l.EndsWith(":"))
                {
                    curObject = ParseObjectName(l);
                    continue;
                }
                var trimmed = l.Trim(trimChars);
                if (trimmed.Length > 0 && (trimmed[0] == 'T' || trimmed[0] == 't' || trimmed[0] == 'W' || trimmed[0] == 'w'))
                {
                    var func = trimmed.Substring(1).Trim(trimChars);
                    if (!result.ContainsKey(func))
                        result[func] = curObject;
                }
            }

            return result;
        }

        static private Dictionary<string, int> GetFunctionSizesFromWast(string wastPath, out int totalWastSize, Dictionary<string, string> minificationMap)
        {
            var processStartInfo = new ProcessStartInfo(EmscriptenPaths.binaryenShellExecutable)
            {
                Arguments = "\"" + wastPath + "\" --nm",
                UseShellExecute = false,
                CreateNoWindow = true,
            };
            var p = new Program(processStartInfo);
            p.Start();
            p.WaitForExit();
            if (p.ExitCode != 0)
            {
                throw new System.Exception("wasm-opt failed with arguments: " + processStartInfo.Arguments);
            }
            var output = p.GetStandardOutput();
            var result = new Dictionary<string, int>();
            totalWastSize = 0;
            foreach (var line in output)
            {
                var split = line.Split(':');
                var funcName = split[0].Trim(' ', '$', '_');
                if (minificationMap.ContainsKey(funcName))
                    funcName = minificationMap[funcName].Trim(' ', '$', '_');
                var funcSize = int.Parse(split[1]);
                result[funcName] = funcSize;
                totalWastSize += funcSize;
            }
            return result;
        }

        protected override Dictionary<string, int> GetFunctionSizes()
        {
            totalSize = 0;

            var functionSizes = new Dictionary<string, int>();
            bool wasm = Path.GetExtension(builtCodePath) == ".wasm";
            var builtCodePathNoExt = builtCodePath.Substring(0, builtCodePath.Length - (wasm ? 5 : 7)); // strip .asm.js or .wasm
            var minificationMap = CodeAnalysisUtils.ReadMinificationMap(builtCodePathNoExt + ".js.symbols");

            if (wasm)
            {
                string wastPath = "Temp/StagingArea/Data/linkresult_wasm/build.wast";
                var processStartInfo = new ProcessStartInfo(EmscriptenPaths.binaryenDisExecutable)
                {
                    Arguments = "\"" + builtCodePath + "\" -o " + wastPath,
                    UseShellExecute = false,
                    CreateNoWindow = true,
                };
                var p = new Program(processStartInfo);
                p.Start();
                p.WaitForExit();
                if (p.ExitCode != 0)
                {
                    throw new System.Exception("wasm-dis failed with arguments: " + processStartInfo.Arguments);
                }

                int totalWastSize;
                functionSizes = GetFunctionSizesFromWast(wastPath, out totalWastSize, minificationMap);
                totalSize = (int)(new FileInfo(builtCodePath).Length);
                float scaleFactor = totalSize / (float)totalWastSize;
                foreach (var func in functionSizes.Keys.ToList())
                    functionSizes[func] = (int)(functionSizes[func] * scaleFactor);
            }
            else
            {
                var code = File.ReadAllText(builtCodePath);
                totalSize = code.Length;
                int index = code.IndexOf("// EMSCRIPTEN_START_FUNCS");
                int endIndex = code.IndexOf("// EMSCRIPTEN_END_FUNCS");
                var jsWrapSize = index + totalSize - endIndex;
                moduleSizes["JS Pre- and Postfix code"] = jsWrapSize;
                AddModule("JS Pre- and Postfix code", false);
                var trimChar = new char[] {'_'};

                CodeAnalysisUtils.ExtractFunctionsFromJS(code,
                    (name, functionCode) => {
                        if (minificationMap.ContainsKey(name))
                            name = minificationMap[name];
                        name = name.Trim(trimChar);
                        if (!functionSizes.ContainsKey(name))
                            functionSizes[name] = 0;
                        functionSizes[name] += functionCode.Length;
                    },
                    (functionCode) => {}
                );
            }
            return functionSizes;
        }

        protected override Dictionary<string, string> GetModuleArtifacts()
        {
            var modulesPath = developmentBuild ? "lib/modules_development" : "lib/modules";
            var libPath = Path.Combine(EmscriptenPaths.buildToolsDir, modulesPath);
            var moduleSymbolArtifactsList = GetDirectorySymbolArtifacts(libPath).ToArray();
            var moduleArtifacts = GetSymbolArtifactsFromNMOutput(moduleSymbolArtifactsList);
            return moduleArtifacts;
        }

        string EmscriptenObjectFileDirectory
        {
            get
            {
                return Il2CppNativeCodeBuilderUtils.ObjectFilePathInCacheDirectoryFor(EmscriptenPaths.cacheDirForIl2CppIncrementalBuildArtifacts);
            }
        }

        string CachePath
        {
            get
            {
                return Path.Combine(EmscriptenPaths.emscriptenCache, "asmjs");
            }
        }

        protected override Dictionary<string, string> GetSymbolArtifacts()
        {
            var doSourceCodeAnalysis = Unsupported.IsSourceBuild();
            IEnumerable<string> symbolArtifactsList = GetDirectorySymbolArtifactsFromGeneratedCode(EmscriptenObjectFileDirectory);
            symbolArtifactsList = symbolArtifactsList.Concat(GetDirectorySymbolArtifactsFromGeneratedCode(Path.Combine(EmscriptenObjectFileDirectory, "libil2cpp")));
            symbolArtifactsList = symbolArtifactsList.Concat(GetDirectorySymbolArtifacts(CachePath));
            if (doSourceCodeAnalysis)
                symbolArtifactsList = symbolArtifactsList.Concat(GetSourceCodeSymbolArtifacts());
            var symbolArtifacts = GetSymbolArtifactsFromNMOutput(symbolArtifactsList);
            return symbolArtifacts;
        }

        protected override void AddPlatformSpecificCodeOutputModules()
        {
            moduleSizes["IL2CPP Generated"] = folderSizes[LeafDirectoryFor(EmscriptenObjectFileDirectory)];
            moduleSizes["libil2cpp"] = folderSizes["libil2cpp"];
            moduleSizes["emscripten runtime"] = folderSizes[CachePath.Replace('\\', '/')];

            AddModule("libil2cpp", false);
            AddModule("IL2CPP Generated", false);
            AddModule("emscripten runtime", false);
        }
    }
}
