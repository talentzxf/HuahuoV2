#pragma once

#include "TransferBase.h"
#include "Serialize/TypeTree.h"
#include "Serialize/SerializeTraits.h"
#include "TypeSystem/Type.h"

class YAMLNode;
struct StreamingInfo;
struct ReduceCopyData;
class ScriptingObjectPtr;

class EXPORT_COREMODULE GenerateTypeTreeTransfer : public TransferBase
{
    TypeTree&       m_TypeTree;
    TypeTreeIterator    m_ActiveFather;
    char*           m_ObjectPtr;
    int             m_ObjectSize;
    char*           m_ScriptingObjectPtr;
    int             m_ScriptingObjectSize;
    int             m_Index;
    int             m_SimulatedByteOffset;
    bool            m_DidErrorAlignment;
    bool            m_RequireTypelessData;

    friend class SerializableManagedRefBackupGenerator;
    friend class SerializableManagedRefTransfer;

public:

    GenerateTypeTreeTransfer(TypeTree& t, TransferInstructionFlags flags, void* objectPtr, int objectSize);

    void SetScriptingObject(ScriptingObjectPtr scriptingObjectPtr, int scriptingObjectSize);
    void SetVersion(int version);
    bool IsVersionSmallerOrEqual(int version) { Assert(m_ActiveFather->m_Version > version); return false; }
    bool IsOldVersion(int version) { Assert(m_ActiveFather->m_Version > version); return false; }
    bool NeedNonCriticalMetaFlags() { return (m_Flags & kDontRequireAllMetaFlags) == 0; }

    void AddMetaFlag(TransferMetaFlags flag) {m_ActiveFather.GetWritableNode(m_TypeTree)->m_MetaFlag = m_ActiveFather->m_MetaFlag | flag; }


    template<class T>
    void TransferBase(T& data, TransferMetaFlags metaFlag = kNoTransferFlags);
    template<class T>
    void Transfer(T& data, const char* name, TransferMetaFlags metaFlag = kNoTransferFlags);
    template<class T>
    void TransferWithTypeString(T& data, const char* name, const char* typeName, TransferMetaFlags metaFlag = kNoTransferFlags);

    void TransferTypeless(UInt32* byteSize, const char* name, TransferMetaFlags metaFlag = kNoTransferFlags);
    void TransferTypelessData(UInt32, void*, int metaData = 0);

    template<class T>
    void TransferBasicData(T& data);

    template<class T>
    void TransferPtr(bool, ReduceCopyData*) {}

    template<class T>
    void TransferSTLStyleArray(T& data, TransferMetaFlags metaFlag = kNoTransferFlags);

    template<class T>
    void TransferSTLStyleMap(T& data, TransferMetaFlags metaFlag = kNoTransferFlags);

    template<class T> inline
    void TransferSTLStyleArrayWithElement(T& elementType, TransferMetaFlags metaFlag);

    void Align();

    void BeginTransfer(const char* name, const char* typeString, char* data, TransferMetaFlags metaFlag);
    void EndTransfer();

    void TransferResourceImage(ActiveResourceImage targetResourceImage, const char* name, StreamingInfo& streamingInfo, void* buffer, UInt32 byteSize, InstanceID instanceID, const HuaHuo::Type* type);

private:

    void LogUnalignedTransfer();
    void AssertContainsNoPPtr(const TypeTreeIterator& type);
    void AssertOptimizeTransfer(int sizeofSize);
    void CheckAlignment();


    void BeginArrayTransfer(const char* name, const char* typeString, SInt32& size, TransferMetaFlags metaFlag);
    void EndArrayTransfer();

    friend class GenerateTypeTreeTransferHelpers;
};

//----------------------------------------------------------------------------------------------------------------------
// What is this: Offers functions that help the serialization layer to modify the TypeTree instance beeing generated by
//               GenerateTypeTreeTransfer, *while* it is beeing generated.
//
// Motivation  :
//  - The methods here are to be used exclusively in the context of the execution of a GenerateTypeTreeTransfer and
//    need to be accessible from outside of GenerateTypeTreeTransfer but without polluting the GenerateTypeTreeTransfer
//    API as they are simply internal to the serialization system.
//----------------------------------------------------------------------------------------------------------------------
class GenerateTypeTreeTransferHelpers
{
public:
    static inline void AddTypeFlagsToActiveNode(GenerateTypeTreeTransfer & transfer, TypeTreeNode::ETypeFlags flags) { transfer.m_ActiveFather.GetWritableNode(transfer.m_TypeTree)->AddTypeFlags(flags); }
};


template<class T> inline
void GenerateTypeTreeTransfer::TransferSTLStyleArray(T& /*data*/, TransferMetaFlags metaFlag)
{
    typedef typename T::value_type ElementType;
    alignas(alignof(ElementType)) char memoryBlock[sizeof(ElementType)];

    ElementType* element = AutoLabelConstructor<ElementType>::construct(memoryBlock, kMemTempAlloc);
    TransferSTLStyleArrayWithElement(*element, metaFlag);
    destruct<ElementType>(element);

    // Make sure MightContainPPtr and AllowTransferOptimization is setup correctly
    DebugAssert(!SerializeTraits<T>::AllowTransferOptimization());
}

template<class T> inline
void GenerateTypeTreeTransfer::TransferSTLStyleArrayWithElement(T& elementType, TransferMetaFlags metaFlag)
{
    SInt32 size;
    BeginArrayTransfer("Array", "Array", size, metaFlag);

    Transfer(elementType, "data");

    EndArrayTransfer();
}

template<class T> inline
void GenerateTypeTreeTransfer::TransferSTLStyleMap(T&, TransferMetaFlags metaFlag)
{
    SInt32 size;
    BeginArrayTransfer("Array", "Array", size, metaFlag);

    typename NonConstContainerValueType<T>::value_type p;
    Transfer(p, "data");

    #if !UNITY_RELEASE
    DebugAssert(!SerializeTraits<T>::AllowTransferOptimization());
    #endif

    EndArrayTransfer();
}

template<class T>
void GenerateTypeTreeTransfer::TransferBase(T& data, TransferMetaFlags metaFlag)
{
    Transfer(data, kTransferNameIdentifierBase, metaFlag);
}

template<class T> inline
void GenerateTypeTreeTransfer::Transfer(T& data, const char* name, TransferMetaFlags metaFlag)
{
#if UNITY_EDITOR
    if (AssetMetaDataOnly() && HasFlag(metaFlag, kIgnoreInMetaFiles))
        return;
#endif

    BeginTransfer(name, SerializeTraits<T>::GetTypeString(&data), (char*)&data, metaFlag);
    SerializeTraits<T>::Transfer(data, *this);

    // Make sure MightContainPPtr and AllowTransferOptimization is setup correctly
    #if !UNITY_RELEASE
    if (!SerializeTraits<T>::MightContainPPtr())
        AssertContainsNoPPtr(m_ActiveFather);
    if (SerializeTraits<T>::AllowTransferOptimization())
        AssertOptimizeTransfer(SerializeTraits<T>::GetByteSize());
    #endif

    EndTransfer();
}

template<class T> inline
void GenerateTypeTreeTransfer::TransferWithTypeString(T& data, const char* name, const char* typeName, TransferMetaFlags metaFlag)
{
    BeginTransfer(name, typeName, (char*)&data, metaFlag);
    SerializeTraits<T>::Transfer(data, *this);
    EndTransfer();
}

template<class T>
inline void GenerateTypeTreeTransfer::TransferBasicData(T&)
{
    m_ActiveFather.GetWritableNode(m_TypeTree)->m_ByteSize = SerializeTraits<T>::GetByteSize();
    #if UNITY_EDITOR
    if (m_SimulatedByteOffset % m_ActiveFather->m_ByteSize != 0)
    {
        LogUnalignedTransfer();
    }
    m_SimulatedByteOffset += m_ActiveFather->m_ByteSize;
    #endif
}
